'''
Created on 6 Dec 2014

@author: Kieran Finn
'''
import numpy as np
from copy import copy
from functions import add_comma,progress_bar

def hot(L):
    out=np.random.random_integers(0,1,(L,L))
    out=out*2-1#switches from 0,1 to -1,1
    return out

def energy(spins):
    '''this is a costly procedure to calculate the energy of a given configuration.
    It should not be necessary to run this more than once (if at all)'''
    up=np.roll(spins, 1, 1)
    down=np.roll(spins,-1,1)
    left=np.roll(spins,1,0)
    right=np.roll(spins,-1,0)
    out=(up+down+left+right)*spins
    out=out/2#I have double counted the bonds
    out=0.-np.sum(out)
    return out

def delta_E(spins,x,y):
    '''calculates the difference in energy generated by flipping spin (x,y).
    much quicker than calculating the full energy again
    delta_E=-sum sig_new*neighbours-(-sum sig_old*neighbours)=(sig_old-sig_new)*sum neighbours
    but sig_new=-sig_old, so delta_E=2sig_old*sum neighbours'''
    Lx,Ly=spins.shape
    neighbours=spins[(x+1)%Lx,y]+spins[(x-1)%Lx,y]+spins[x,(y+1)%Ly]+spins[x,(y-1)%Ly]
    return 2.*spins[x,y]*neighbours

def magnetisation(spins):
    return np.sum(spins)
def delta_M(spins,x,y):#these two functions are probably unnecesary
    return 0.-2*spins[x,y]

def metro(beta,L,start,iterations,spins0=None,partial=False):
    print 'Running %s iterations of the Metropolis algorithm with beta=%g and %s start on a %dx%d grid' %(add_comma(iterations),beta,start,L,L)
    
    '''initialise'''
    if start=='hot':
        spins=hot(L)
    elif start=='cold':
        spins=np.ones([L,L])
    else:
        spins=copy(spins0)
    
    spins0=copy(spins)
    E=energy(spins)
    M=magnetisation(spins)
    
    energies=[E]
    magnetisations=[M]
    changes=[]
    
    '''Main loop'''
    for i in range(iterations):
        if (i+1)%10000==0:
            progress_bar(i,iterations)
        x=np.random.randint(L)
        y=np.random.randint(L)
        de=delta_E(spins,x,y)
        p=np.exp(-beta*de)#probability to accept proposal change this for a different algorithm
        if np.random.rand()<p:#accept
            E+=de
            M+=delta_M(spins,x,y)
            changes.append((x,y))
            spins[x,y]*=-1
        else:
            changes.append(False)
        energies.append(E)
        magnetisations.append(M)
    print '\n'
    if partial:
        return [energies,magnetisations,spins]
    else:
        return [energies,magnetisations,spins0,changes]